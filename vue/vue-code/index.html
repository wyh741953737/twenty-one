<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
</head>
<body>
  <div id="app">
    <!-- <p>{{counter}}</p> -->
    <!-- <button @click="btnClick('aaa')">点击事件</button> -->
    <!-- <button @click="btnClickNo">点击事件2</button> -->
    <span>{{desc}}</span>
    <!-- <input type="text" v-model="desc"> -->
    <!-- <p>{{name}}</p>
    <p v-html="desc"></p>
    <p v-text="counter"></p> -->

  </div>
  <script>
    // 观察者：订阅者，watcher。   被观察者：被订阅的变量，依赖，deps
    // 观察者模式：一对多，是一种行为模式，行为模式关注的是对象之间的通信，
    // 观察者模式：观察者直接订阅发布者，当主题被激活时会触发观察者的事件
    // 发布订阅模式：订阅者把自己想订阅的事注册到调度中心，当发布者发布这个事件，由调度中心统一调度
  
    const watchers = []
    
    // const arrayProto = Object.create(Array.prototype)
    // ['push', 'pop', 'shift', 'unshift'].forEach(method => {
    //   arrayProto[method] = function() {
    //     Array.prototype[method].apply(this, arguments)
    //     // 覆盖操作，通知更新
    //     console.log('数组执行' + method + '操作')
    //   }
    // })
    
    function defineReactive(obj, key, val) {
      // 创建Dep实例
      const dep = new Dep()
      observe(val)
      Object.defineProperty(obj, key, {
        get() {
          console.log('get', key)
          // 依赖收集
          Dep.target && dep.addDep(Dep.target)
          return val
        },
        set(newVal) {
          console.log('set', key)
          if(newVal !== val) {
            observe(newVal)
            val = newVal
            dep.notify()
          }
        }
      })
    }

    class Dep {
      // 观察者
      constructor() {
        this.deps = []
      }
      addDep(dep) {
        this.deps.push(dep)
      }
      notify() {
        this.deps.forEach(dep => dep.update())
      }
    }

    class Observer {
      // 根据传入value的类型做相应的响应式处理
      constructor(value) {
        this.value = value
        if(Array.isArray(value)) {
          // 处理数组的响应式
        } else if(typeof value === 'object') {
          // 处理对象的响应式
          this.walk(value)
        }
      }
      walk(obj) {
        Object.keys(obj).forEach(key => defineReactive(obj, key, obj[key]))
      }
    }
  
    // 监听器，负责依赖的更新
    class Watcher {
      constructor(vm, key, updateFn) {
        this.vm = vm
        this.key = key
        this.updateFn = updateFn
        // watchers.push(this)
        Dep.target = this
        this.vm[this.key]
        Dep.target = null
      }
      update() {
        // 执行实际的更新操作
        this.updateFn.call(this.vm, this.vm[this.key])
      }
    }
    
    function observe(obj) {
      if(typeof obj !== 'object' || obj === null) return
      // if(Array.isArray(obj)) {
      //   obj.__proto__ = arrayProto // 覆盖原型，替换7个变更操作
      //   // 对数组内部元素执行响应式
      //   const keys = Object.keys(obj)
      //   for(let i = 0; i < obj.length; i++) {
      //     observe(obj[i])
      //   }
      // } else {
      // }
      new Observer(obj)
    }

    function proxy(vm) {
      Object.keys(vm.$data).forEach(key => {
        Object.defineProperty(vm, key, {
          get() {
            return vm.$data[key]
          },
          set(val) {
            vm.$data[key] = val
          }
        })
      })
    }
  
    class KVue {
      constructor(options) {
        this.$options = options
        this.$data = options.data

        // 响应式处理
        observe(this.$data)
        proxy(this)
        // 编译
        // 获取dom，遍历子元素（[编译节点，遍历属性[遍历k-开头（k-html处理innerHtml， k-model监听input）， 遍历at开头（绑定click）]], 编译文本
        new Compile(options.el, this)
      }
    }
    // 处理插值，指令和事件，以及初始化和更新
    class Compile {
      constructor(el, vm) {
        this.$vm = vm
        this.$el = document.querySelector(el) // 做判断
        if(this.$el) {
          this.compile(this.$el)
        }
      }
      update(node, exp, dir) {
        // 1:初始化，一上来就能看到的值
        const fn = this[dir+'Updater']
        fn && fn(node, this.$vm[exp])

        // 2：更新
        new Watcher(this.$vm, exp, function(val) {
          fn && fn(node, val)
        })
      }
      textUpdater(node, value) {
        node.textContent = value
      }
      htmlUpdater(node, value) {
        node.innerHTML = value
      }
      
      compile(el) {
        // 遍历el子节点，判断类型
        const childNodes = el.childNodes
        childNodes.forEach(node => {
          if(node.nodeType === 1) {
            // 元素, 判断属性
            // 处理指令和事件
            const attrs = node.attributes
            Array.from(attrs).forEach(attr => {
              // v-xxx='aaa'
              const attrName = attr.name
              let exp = attr.value
              if(this.isDirective(attrName)) {
                const dir = attrName.substring(2)
                this[dir] && this[dir](node, exp)
              }
              // 事件处理
              if(this.isEvent(attrName)) {
                const dir = attrName.substring(1)
                this.eventHandler(node, exp, dir )
              }
            })
          } else if(this.isInter(node)) {
            // 文本
            this.compileText(node)
          }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
          if(node.childNodes) {
            this.compile(node)                                                                                                                                                                                                                                                                     
          }
        })
      }
      // 判断是否是插值表达式{{}}
      isInter(node) {
        return node.nodeType === 3 && /\{\{(.*)\}\}/.test(node.textContent)
      }
      compileText(node) {
        // node.textContent = this.$vm[RegExp.$1]  // RegExp.$1是RegExp的一个属性,指的是与正则表达式匹配的第一个子匹配(以括号为标志)字符串
        this.update(node, RegExp.$1, 'text')
      }
      // k-text
      text(node, exp) {
        // node.textContent = this.$vm[exp]
        this.update(node, exp, 'text')
      }
      html(node, exp) {
        this.update(node, exp, 'html')
      }
      isEvent(dir) {
        return dir.indexOf('@') == 0
      }
      eventHandler(node, exp, dir) {
        const fn = this.$vm.$options.methods && this.$vm.$options.methods[exp]
        console.log(fn, this.$vm.$options.methods, exp)
        node.addEventListener(dir, fn.bind(this.$vm))
      }
      isDirective(attr) {
        return attr.startsWith('v-')
      }
      // v-model='xxx'
      model(node, exp) {
        // update只完成赋值和更新，不完成事件监听
        this.update(node, exp, 'model')
        node.addEventListener('input', e => {
          this.$vm[exp] = e.target.value
        })
      }
      modelUpdater(node, value) {
        // 表单元素赋值
        node.value = value
      }
    }

    const app = new Vue({
      el: '#app',
      data: {
        counter: 1,
        arr: ['曦'],
        desc: '<span>你好啊</span>'
      },
      methods: {
        btnClick(str) {
          console.log('我是this',this, str)
          this.counter++
        },
        btnClickNo() {
          this.counter++
        },
        inputVlaue() {

        }
      },
      mounted() {
        setTimeout(() => {
          this.desc = '我是mount中变化的'
        }, 1000)
      },
    })
  </script>
</body>
</html>