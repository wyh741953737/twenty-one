<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
</head>

<body>
  <div id="app">
    <h1 v-html="desc.text"></h1>
    <h2 v-html="desc2"></h2>
  </div>
  <script>
    const watchers = []
    function defineReactive(obj, key, val) {
      const dep = new Dep() // key和Dep一一对应
      observe(val)
      Object.defineProperty(obj, key, {
        get() {
          console.log('触发get====', key)
          // 依赖收集
          Dep.target && dep.addDep(Dep.target)
          return val
        },
        set(newVal) {
          console.log('触发set====', key)
          if (newVal !== val) {
            observe(newVal)
            val = newVal
            dep.notify() // 数据发生改变通知界面变化
          }
        }
      })
    }

    class Dep {
      constructor() {
        this.deps = []
      }
      addDep(dep) {
        this.deps.push(dep)
      }
      notify() {
        this.deps.forEach(dep => dep.update())
      }
    }

    class Observer {
      // 根据传入value的类型做相应的响应式处理
      constructor(value) {
        this.value = value
        if (Array.isArray(value)) {
          // 处理数组的响应式
        } else if (typeof value === 'object') {
          // 处理对象的响应式
          this.walk(value)
        }
      }
      walk(obj) {
        Object.keys(obj).forEach(key => defineReactive(obj, key, obj[key]))
      }
    }

    // 监听器，负责依赖的更新
    class Watcher {
      constructor(vm, key, updateFn) {
        this.vm = vm
        this.key = key
        this.updateFn = updateFn
        Dep.target = this
        this.vm[this.key]
        Dep.target = null
      }
      update() {
        // 执行实际的更新操作
        this.updateFn.call(this.vm, this.vm[this.key])
      }
    }

    function observe(obj) {
      if (typeof obj !== 'object' || obj === null) return
      new Observer(obj)
    }

    function proxy(vm) {
      Object.keys(vm.$data).forEach(key => {
        Object.defineProperty(vm, key, {
          get() {
            return vm.$data[key]
          },
          set(val) {
            vm.$data[key] = val
          }
        })
      })
    }

    class KVue {
      constructor(options) {
        this.$options = options
        this.$data = options.data
        // 响应式处理
        observe(this.$data)
        proxy(this)
        // 编译 获取dom，遍历子元素（[编译节点，遍历属性[遍历k-开头（k-html处理innerHtml， k-model监听input）， 遍历at开头（绑定click）]], 编译文本
        new Compile(options.el, this)
      }
    }
    // 处理插值，指令和事件，以及初始化和更新
    class Compile {
      constructor(el, vm) {
        this.$vm = vm
        this.$el = document.querySelector(el) // 做判断
        if (this.$el) {
          this.compile(this.$el)
        }
      }
      update(node, exp, dir) {
        // 1:初始化，一上来就能看到的值
        const fn = this[dir + 'Updater']
        fn && fn(node, this.$vm[exp])

        // 2：更新
        new Watcher(this.$vm, exp, function (val) {
          fn && fn(node, val)
        })
      }
      textUpdater(node, value) {
        node.textContent = value
      }
      htmlUpdater(node, value) {
        node.innerHTML = value
      }

      compile(el) {
        // 遍历el子节点，判断类型
        const childNodes = el.childNodes
        childNodes.forEach(node => {
          if (node.nodeType === 1) {
            // 元素, 判断属性，处理指令和事件
            const attrs = node.attributes
            Array.from(attrs).forEach(attr => {
              // v-xxx='aaa'
              const attrName = attr.name
              let exp = attr.value
              if (this.isDirective(attrName)) {
                const dir = attrName.substring(2)
                this[dir] && this[dir](node, exp)
              }
              // 事件处理
              if (this.isEvent(attrName)) {
                const dir = attrName.substring(1)
                this.eventHandler(node, exp, dir)
              }
            })
          } else if (this.isInter(node)) {
            // 文本
            this.compileText(node)
          }
          if (node.childNodes) {
            this.compile(node)
          }
        })
      }
      // 判断是否是插值表达式{{}}
      isInter(node) {
        return node.nodeType === 3 && /\{\{(.*)\}\}/.test(node.textContent)
      }
      compileText(node) {
        // node.textContent = this.$vm[RegExp.$1]  // RegExp.$1是RegExp的一个属性,指的是与正则表达式匹配的第一个子匹配(以括号为标志)字符串
        this.update(node, RegExp.$1, 'text')
      }
      // k-text
      text(node, exp) {
        // node.textContent = this.$vm[exp]
        this.update(node, exp, 'text')
      }
      html(node, exp) {
        this.update(node, exp, 'html')
      }
      isEvent(dir) {
        return dir.indexOf('@') == 0
      }
      eventHandler(node, exp, dir) {
        const fn = this.$vm.$options.methods && this.$vm.$options.methods[exp]
        console.log(fn, this.$vm.$options.methods, exp)
        node.addEventListener(dir, fn.bind(this.$vm))
      }
      isDirective(attr) {
        return attr.startsWith('v-')
      }
      // v-model='xxx'
      model(node, exp) {
        // update只完成赋值和更新，不完成事件监听
        this.update(node, exp, 'model')
        node.addEventListener('input', e => {
          this.$vm[exp] = e.target.value
        })
      }
      modelUpdater(node, value) {
        // 表单元素赋值
        node.value = value
      }
    }
    const app = new Vue({
      el: '#app',
      data: {
        desc: {
          text: '<span>你好啊</span>'
        },
        desc2: '<span>你好啊</span>'
      }
    })
    console.log(app)
    app._data.desc.text = '<span>我变身了</span>'
      // 观察者：订阅者，watcher。   被观察者：被订阅的变量，依赖，deps
        // 观察者模式：一对多，是一种行为模式，行为模式关注的是对象之间的通信，
        // 观察者模式：观察者直接订阅发布者，当主题被激活时会触发观察者的事件
        // 发布订阅模式：订阅者把自己想订阅的事注册到调度中心，当发布者发布这个事件，由调度中心统一调度
  </script>
  <script>

  </script>
</body>

</html>