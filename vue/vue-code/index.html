<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
  <script src="./public.js"></script>
</head>
<body>
  <div id="app">
    <p>{{counter}}</p>
    <p>{{name}}</p>
    <p k-html="desc"></p>
    <p k-text="counter"></p>

  </div>
  <script>
    // 观察者：订阅者，watcher。   被观察者：被订阅的变量，依赖，deps
    // 观察者模式：一对多，是一种行为模式，行为模式关注的是对象之间的通信，
    // 观察者模式：观察者直接订阅发布者，当主题被激活时会触发观察者的事件
    // 发布订阅模式：订阅者把自己想订阅的事注册到调度中心，当发布者发布这个事件，由调度中心统一调度
    // 数据响应式
    function defineReactive(obj, key, val) {
      observe(val)
      Object.defineProperty(obj, key, {
        get() {
          console.log('get', key)
          return val
        },
        set(newVal) {
          console.log('set', key)
          if(newVal !== val) {
            observe(newVal)
            val = newVal
          }
        }
      })
    }

    class Observer {
      // 根据传入value的类型做相应的响应式处理
      constructor(value) {
        this.value = value
        if(Array.isArray(value)) {
          // 处理数组的响应式
        } else if(typeof value === 'object') {
          // 处理对象的响应式
          this.walk(value)
        }
      }
      walk(obj) {
        Object.keys(obj).forEach(key => defineReactive(obj, key, obj[key]))
      }
    }
  
    function observe(obj) {
      if(typeof obj !== 'object' || obj === null) return
      new Observer(obj)
    }

    function proxy(vm) {
      Object.keys(vm.$data).forEach(key => {
        Object.defineProperty(vm, key, {
          get() {
            return vm.$data[key]
          },
          set(val) {
            vm.$data[key] = val
          }
        })
      })
    }
    class KVue {
      constructor(options) {
        this.$options = options
        this.$data = options.data

        // 响应式处理
        observe(this.$data)
        proxy(this)
        // 编译
        // 获取dom，遍历子元素（[编译节点，遍历属性[遍历k-开头（k-html处理innerHtml， k-model监听inpur）， 遍历at开头（绑定click）]], 编译文本
        new Compile(options.el, this)
      }
    }
    // 处理插值，指令和事件，以及初始化和更新
    class Compile {
      constructor(el, vm) {
        this.$vm = vm
        this.$el = document.querySelector(el) // 做判断
        if(this.$el) {
          this.compile(this.$el)
        }
      }
      compile(el) {
        // 遍历el子节点，判断类型
        const childNodes = el.childNodes
        childNodes.forEach(node => {
          if(node.nodeType === 1) {
            // 元素, 判断属性
            console.log('元素', node.textContent)
            // 处理指令和事件
            const attrs = node.attributes
            Array.from(attrs).forEach(attr => {
              // k-xxx='aaa'
              const attrName = attr.name
              const exp = attr.value
              if(attrName.startsWith('k-')) {
                const dir = attrName.substring(2)
                this[dir] && this[dir](node, exp)
              }
            })
          } else if(this.isInter(node)) {
            // 文本
            console.log('插值', node.textContent)
            this.compileText(node)
          }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
          if(node.childNodes) {
            this.compile(node)                                                                                                                                                                                                                                                                     
          }
        })
      }
      // 判断是否是插值表达式{{}}
      isInter(node) {
        return node.nodeType === 3 && /\{\{(.*)\}\}/.test(node.textContent)
      }
      compileText(node) {
        node.textContent = this.$vm[RegExp.$1]  // RegExp.$1是RegExp的一个属性,指的是与正则表达式匹配的第一个子匹配(以括号为标志)字符串
      }
      text(node, exp) {
        node.textContent = this.$vm[exp]
      }
      html(node, exp) {
        node.innerHTML = this.$vm[exp]
      }
    }

    const app = new KVue({
      el: '#app',
      data: {
        counter: 1,
        name: '信息',
        desc: '<psan>你好</span>'
      }
    })
    setInterval(() => {
      app.$data.counter++
    }, 2000)
  </script>
</body>
</html>