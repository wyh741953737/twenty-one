"use strict";

const webpack = require("webpack");
const {  isColorSupported} = require("colorette");


function setupHooks(context) {
  // 判断是否是invalid阶段
  function invalid() {
    if (context.state) {
      context.logger.log("Compilation starting...");
    } // We are now in invalid state
    context.state = false;
    context.stats = undefined;
  }

  // 获取stats
  const statsForWebpack4 = webpack.Stats && webpack.Stats.presetToOptions;
  // 格式化stats，里面有preset
  function normalizeStatsOptions(statsOptions) {
    if (statsForWebpack4) {
      if (typeof statsOptions === "undefined") {
        statsOptions = {};
      } else if (typeof statsOptions === "boolean" || typeof statsOptions === "string") {
        statsOptions = webpack.Stats.presetToOptions(statsOptions);
      } // @ts-ignore


      return statsOptions;
    }

    if (typeof statsOptions === "undefined") {
      statsOptions = {  preset: "normal" };
    } else if (typeof statsOptions === "boolean") {
      statsOptions = statsOptions ? {
        preset: "normal"
      } : {
        preset: "none"
      };
    } else if (typeof statsOptions === "string") {
      statsOptions = {
        preset: statsOptions
      };
    }

    return statsOptions;
  }


  function done(stats) {
    context.state = true; 
    context.stats = stats; // Do the stuff（填充物） in nextTick, because bundle may be invalidated if a change happened while compiling
    process.nextTick(() => {
      const { compiler, logger, options, state, callbacks } = context;
      // Check if still in valid state
      if (!state) {
        return;
      }
      logger.log("编译完成");
      const isMultiCompilerMode = Boolean(compiler.compilers);

      let statsOptions;

      if (typeof options.stats !== "undefined") {
        statsOptions = isMultiCompilerMode ? {
          children: compiler.compilers.map(() => options.stats)
        } : options.stats;
      } else {
        statsOptions = isMultiCompilerMode ? {
          children: compiler.compilers.map(child => child.options.stats)
        } : compiler.options.stats;
      }

      if (isMultiCompilerMode) {
        statsOptions.children = statsOptions.children.map( childStatsOptions => {
          childStatsOptions = normalizeStatsOptions(childStatsOptions);
          if (typeof childStatsOptions.colors === "undefined") {
            childStatsOptions.colors = isColorSupported;
          }
          return childStatsOptions;
        });
      } else {
        statsOptions = normalizeStatsOptions(statsOptions);

        if (typeof statsOptions.colors === "undefined") {
          statsOptions.colors = isColorSupported;
        }
      } 

      if (compiler.compilers && statsForWebpack4) {
        statsOptions.colors =  statsOptions.children.some(child => child.colors);
      }

      context.callbacks = []; // Execute callback that are delayed

      callbacks.forEach(callback => {
        callback(stats);
      });
    });
  }

  context.compiler.hooks.watchRun.tap("webpack-dev-middleware", invalid);
  context.compiler.hooks.invalid.tap("webpack-dev-middleware", invalid);
  context.compiler.hooks.done.tap("webpack-dev-middleware", done);
}

module.exports = setupHooks;