
const path = require("path");
const {  parse} = require("url");
const querystring = require("querystring");

const getPaths = require("./getPaths");


const cacheStore = new WeakMap();

const mem = (fn, {
  cache = new Map()
} = {}) => {

  const memoized = (...arguments_) => {
    const [key] = arguments_;
    const cacheItem = cache.get(key);

    if (cacheItem) {
      return cacheItem.data;
    }

    const result = fn.apply(void 0, arguments_);
    cache.set(key, {
      data: result
    });
    return result;
  };

  cacheStore.set(memoized, cache);
  return memoized;
};

const memoizedParse = mem(parse);

function getFilenameFromUrl(context, url) {
  const {
    options
  } = context;
  const paths = getPaths(context);
  let foundFilename;
  let urlObject;

  try {
    // The `url` property of the `request` is contains only  `pathname`, `search` and `hash`
    urlObject = memoizedParse(url, false, true);
  } catch (_ignoreError) {
    return;
  }

  for (const {
    publicPath,
    outputPath
  } of paths) {
    let filename;
    let publicPathObject;

    try {
      publicPathObject = memoizedParse(publicPath !== "auto" && publicPath ? publicPath : "/", false, true);
    } catch (_ignoreError) {
      continue;
    }

    if (urlObject.pathname && urlObject.pathname.startsWith(publicPathObject.pathname)) {
      filename = outputPath; // Strip the `pathname` property from the `publicPath` option from the start of requested url

      const pathname = urlObject.pathname.slice(publicPathObject.pathname.length);

      if (pathname) {
        filename = path.join(outputPath, querystring.unescape(pathname));
      }

      let fsStats;

      try {
        fsStats =
        context.outputFileSystem.statSync(filename);
      } catch (_ignoreError) {
        continue;
      }

      if (fsStats.isFile()) {
        foundFilename = filename;
        break;
      } else if (fsStats.isDirectory() && (typeof options.index === "undefined" || options.index)) {
        const indexValue = typeof options.index === "undefined" || typeof options.index === "boolean" ? "index.html" : options.index;
        filename = path.join(filename, indexValue);

        try {
          fsStats = context.outputFileSystem.statSync(filename);
        } catch (__ignoreError) {
          continue;
        }

        if (fsStats.isFile()) {
          foundFilename = filename;
          break;
        }
      }
    }
  } 


  return foundFilename;
}

module.exports = getFilenameFromUrl;