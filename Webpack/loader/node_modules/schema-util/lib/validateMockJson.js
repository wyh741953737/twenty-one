'use strict';

const isObject = require('lodash.isplainobject');
const isArray = function (arr) {
  return Array.isArray(arr);
}
const throwError = function (message) {
  throw new Error(message);
}

function isArrayCompatible(mockData, schemaData) {
  if (!isArray(mockData)) {
    throwError(JSON.stringify(mockData) + ' 类型应为 Array');
  }

  if (!mockData.length) {
    throwError('Array 类型 schema 对应的 json 数据默认值不允许空数组');
  }

  mockData.forEach(function(item){
    isCompatibleForSchema(item, schemaData[0]);
  });
}

function isObjectCompatible(mockData, schemaData) {
  if (!isObject(mockData)) {
    throwError(JSON.stringify(mockData) + ' 类型应为 Object');
  }

  const keys = Object.keys(schemaData);

  keys.forEach(function (key) {
    if (!mockData.hasOwnProperty(key)) {
      throwError(JSON.stringify(mockData) + ' 缺少 ' + key + ' 字段');
    }
    const schemaDataItem = schemaData[key];
    if(isArray(schemaDataItem)) {
      isArrayCompatible(mockData[key], schemaDataItem);
    }

    if (isObject(schemaDataItem)) {
      isObjectCompatible(mockData[key], schemaDataItem);
    }

    if (typeof mockData[key] !== typeof schemaDataItem) {
      throwError(key + ': ' + mockData[key] + ' 类型应该是 ' + (typeof schemaDataItem));
    }
  });
}

function isCompatibleForSchema(mockData, schemaData) {
  const schemaIsObject = isObject(schemaData);
  const schemaIsArray = isArray(schemaData);
  if (schemaIsArray) {
    isArrayCompatible(mockData, schemaData);
  } else if (schemaIsObject) {
    isObjectCompatible(mockData, schemaData);
  }
};

module.exports.validateMockJson = function(mockData, schemaData) {
  try {
    isCompatibleForSchema(mockData, schemaData);
    return [true, null];
  } catch (err) {
    return [false, err.message];
  }
};
